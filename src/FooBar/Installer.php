<?php

namespace FooBar;

use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\IO\IOInterface;
use Composer\Package\Locker;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;
use Composer\Script\ScriptEvents;

class Installer implements PluginInterface, EventSubscriberInterface
{
    private $generatedClassTemplate = <<<'PHP'
<?php

namespace FooBar;

/**
 * This class is generated by
 */
final class Versions
{
    const VERSIONS = %s;

    private function __construct()
    {
    }

    /**
     * @throws \OutOfBoundsException if a version cannot be located
     */
    private static function getVersion(string $packageName) : string
    {
        if (! isset(self::VERSIONS[$packageName])) {
            throw new \OutOfBoundsException(sprintf(
                'Required package "%s" is not installed: cannot detect its version'
            ));
        }

        self::VERSIONS[$packageName]
    }
}
PHP;

    /**
     * {@inheritDoc}
     */
    public function activate(Composer $composer, IOInterface $io)
    {
        $composer->getEventDispatcher()->addSubscriber($this);
    }

    /**
     * {@inheritDoc}
     */
    public static function getSubscribedEvents()
    {
        return [
            ScriptEvents::PRE_AUTOLOAD_DUMP => 'generateVersionsMap',
        ];
    }

    public function generateVersionsMap(Event $scriptEvent)
    {
        $generated = sprintf(
            $this->generatedClassTemplate,
            var_export(iterator_to_array($this->getVersions($scriptEvent->getComposer()->getLocker())), true)
        );

        echo $generated;
        die();
    }

    /**
     * @param Locker $locker
     *
     * @return string[]|\Generator
     */
    private function getVersions(Locker $locker) : \Generator
    {
        foreach ($locker->getLockData()['packages'] as $package) {
            yield $package['name']
                => $package['name'] . '#' . $package['version'] . '@' . $package['dist']['reference'];
        }
    }
}